# Introduction and Purpose

The **Personalised Lobby** project is a backend service that delivers customized gaming content for multiple online casino “ventures” (sites/brands) and platforms (e.g. desktop or mobile). It allows the frontend client to fetch **personalized lobby content** – such as navigation menus, game listings, and recommendations – via a set of API endpoints. Content is managed by non-technical staff in a headless CMS (Contentful) and stored in an AWS **OpenSearch** cluster for fast retrieval by the APIs. The system ensures that each player sees a lobby tailored to their profile (e.g. recently played games, recommended games) as well as content specific to their region and site. In simpler terms, this codebase powers the dynamic lobby experience on the front-end, determining *what games or categories to show to each user and in what order*, using data from a CMS and user activity.

From a non-technical perspective, this project’s goal is to serve the right games to the right players. Business stakeholders can define the lobby layout and sections (e.g. “Top Picks”, “New Games”, “Recommended for You”) in Contentful. The backend then exposes endpoints that the front-end calls to render these sections – pulling data from an OpenSearch database that is kept in sync with the Contentful content. If a user is logged in, the service can personalize certain sections (like showing games the user has played or ones an algorithm suggests). If no user data is available, it falls back to default content. Overall, this system ensures the lobby page on each site is **content-driven** (easily updated via CMS) and **personalized per user** (via data-driven recommendations).

## Tech Stack and Key Technologies

This project is implemented as an **AWS serverless backend** using a modern TypeScript stack. Below are the main technologies and components involved:

- **AWS Lambda** – All backend logic is implemented as Node.js 20 Lambda functions (written in TypeScript). Each API endpoint corresponds to a Lambda function that executes on demand in a serverless environment. The lambdas run on Node.js 20.x runtime and use AWS SDKs for AWS service access[GitHub](https://github.com/devminchev/tech-docs/blob/69c62ef62c3e714eea9f7246b08c7568435d8b05/docs/tech-stack.md#L3-L8).
- **AWS API Gateway** – The Lambdas are exposed via a REST API (defined using AWS SAM). API Gateway routes HTTP requests to the appropriate Lambda based on the URL path and method. All endpoints are part of a single API Gateway deployment (named “lobby-v3” in the template) so that the front-end interacts with one unified API URL.
- **AWS SAM (Serverless Application Model)** – Infrastructure is defined as code in a CloudFormation/SAM template (`template.yaml`). SAM is used for building, packaging, and deploying the collection of Lambdas and related resources. It defines each Lambda function, an API Gateway, and any layers or permissions needed. Developers can use SAM CLI commands to build and deploy the stack both locally and to AWS (including `sam build`, `sam local invoke`, `sam deploy`, etc., as described later).
- **Nx Monorepo** – The codebase is organized as an Nx-managed monorepo (Nrwl Nx) named **`personalised-lobby-ts-lambda-v3`**[GitHub](https://github.com/devminchev/tech-docs/blob/69c62ef62c3e714eea9f7246b08c7568435d8b05/docs/tech-stack.md#L3-L8). Nx provides a standardized structure and tooling for building, testing, and linting multiple projects within the repository. In this repo, each Lambda function is a separate project (tagged as `type:app` in Nx), and there is a shared library project for common code. Nx helps run tasks like build or test across all functions and handle inter-project dependencies efficiently. It also allows for incremental builds (only rebuilding “affected” functions) and consistent scripts via the Nx CLI.
- **Programming Language**: **TypeScript** – The Lambdas and library are written in TypeScript, enabling static typing and modern JS features. The code is compiled to JS (es2020 target) using **esbuild** as part of the build process (configured via Nx). TypeScript improves code quality and maintainability for the development team.
- **Contentful (Headless CMS)** – Contentful is used to manage lobby content (sections, game entries, layouts, etc.). Non-technical users can add or edit content in Contentful. The backend uses Contentful’s **Management API** to fetch content entries when needed (for example, on certain webhook events or potentially if live data is required)[GitHub](https://gitlab.ballys.tech/excite/native/applications/personalised-lobby-ts-lambda-v3/blob/75c6ff00142d6935e18342f64345d97b3229adb6/functions/PostHistoricalGameTitlesHandlerFunction/app.ts#L23-L31)[GitHub](https://gitlab.ballys.tech/excite/native/applications/personalised-lobby-ts-lambda-v3/blob/75c6ff00142d6935e18342f64345d97b3229adb6/functions/PostHistoricalGameTitlesHandlerFunction/app.ts#L55-L64). Contentful is the source of truth for the lobby configuration (which games belong to which section, what a section is named, etc.), and changes in Contentful ultimately propagate to what the Lambdas return via the API.
- **OpenSearch (Amazon OpenSearch Service)** – OpenSearch is the primary data store for serving lobby content. All relevant content from Contentful is indexed into OpenSearch indices, enabling fast search and retrieval. The Lambdas query OpenSearch for data such as lists of games, navigation items, section definitions, and personalized recommendations. (OpenSearch is Amazon’s open-source search engine, compatible with Elasticsearch.) The code uses the official OpenSearch JS client[GitHub](https://gitlab.ballys.tech/excite/native/applications/personalised-lobby-ts-lambda-v3/blob/75c6ff00142d6935e18342f64345d97b3229adb6/package.json#L42-L50) to send search and aggregation queries. By using OpenSearch, the service can handle complex filtering, full-text search for games, and quick lookups of content by IDs.
- **AWS OpenSearch vs Contentful**: In practice, Contentful content is periodically pushed into OpenSearch indices (often via background jobs or webhooks) so that the Lambdas can read from a fast, queryable store rather than directly from the CMS on each request. This design gives low-latency responses to the user and offloads heavy querying from the CMS. (One Lambda does interact with Contentful directly on specific events – see “Historical Game Titles” handler below – but the majority of requests hit OpenSearch.)
- **Custom OpenSearch Client Library (os-client)** – The repository includes a shared library called **OSClient** (located under `libs/OSClient`) which abstracts the connection and queries to OpenSearch[GitHub](https://gitlab.ballys.tech/excite/native/applications/personalised-lobby-ts-lambda-v3/blob/75c6ff00142d6935e18342f64345d97b3229adb6/libs/OSClient/README.md#L3-L11). This library contains reusable utilities for building queries, handling responses, and managing OpenSearch indices and aliases used by the project. It is implemented as an **AWS Lambda Layer** so that it can be shared across all Lambdas without duplicating code. At runtime, the OSClient layer is mounted to `/opt/nodejs/node_modules/os-client` in each Lambda’s environment, and the Lambdas import it from that path. In development, TypeScript path mapping is used to resolve `/opt/nodejs/node_modules/os-client` to the local library source, allowing developers to import `os-client` seamlessly during local testing[GitHub](https://gitlab.ballys.tech/excite/native/applications/personalised-lobby-ts-lambda-v3/blob/75c6ff00142d6935e18342f64345d97b3229adb6/functions/GetNavigationFunction/README.md#L10-L19). The OSClient library includes constants for index names, functions for common query patterns, error handling helpers, and personalization logic (e.g. functions to handle “recently played” or “recommended for you” queries)[GitHub](https://gitlab.ballys.tech/excite/native/applications/personalised-lobby-ts-lambda-v3/blob/75c6ff00142d6935e18342f64345d97b3229adb6/libs/OSClient/index.ts#L10-L19)[GitHub](https://gitlab.ballys.tech/excite/native/applications/personalised-lobby-ts-lambda-v3/blob/75c6ff00142d6935e18342f64345d97b3229adb6/libs/OSClient/index.ts#L126-L135). Using a layer for this library keeps each Lambda’s package size small and ensures all functions use the same tested query logic.
- **AWS SDKs and Other Dependencies** – The Lambdas use AWS SDK v2 (for X-Ray, etc.) and v3 (for credentials) as needed[GitHub](https://github.com/devminchev/tech-docs/blob/69c62ef62c3e714eea9f7246b08c7568435d8b05/docs/tech-stack.md#L3-L8). Notably, AWS X-Ray is enabled in the project to trace and debug requests (so one can track a request through API Gateway, Lambda, and OpenSearch queries). The code also utilizes the **Contentful Management SDK** (`contentful-management` and Contentful’s Node apps toolkit) for interacting with the CMS[GitHub](https://gitlab.ballys.tech/excite/native/applications/personalised-lobby-ts-lambda-v3/blob/75c6ff00142d6935e18342f64345d97b3229adb6/package.json#L42-L49), **Axios** for any HTTP calls (for example, if calling external services or perhaps the CMS REST API), and utility libraries. The environment is configured for **AWS X-Ray** (though not heavily referenced in code, it’s likely auto-captured by the AWS SDK).
- **Testing & CI Tooling** – The development process relies on several tools:
    - **Jest** for unit testing (with support for mocks like `nock` to simulate HTTP calls[GitHub](https://gitlab.ballys.tech/excite/native/applications/personalised-lobby-ts-lambda-v3/blob/75c6ff00142d6935e18342f64345d97b3229adb6/package.json#L79-L82)). Each function has its own test suite (in a `tests` folder) to validate its logic in isolation.
    - **ESLint** and **Prettier** for code linting and formatting, ensuring a consistent code style. These run as part of Nx workflows (e.g., `nx lint` on all projects) and even as pre-commit hooks (the repo uses Husky and lint-staged) to enforce quality before code is checked in.
    - **Commitlint** following the **Conventional Commits** standard – The project uses conventional commit messages (types like feat, fix, chore, etc.)[GitHub](https://gitlab.ballys.tech/excite/native/applications/personalised-lobby-ts-lambda-v3/blob/75c6ff00142d6935e18342f64345d97b3229adb6/README.md#L335-L344)[GitHub](https://gitlab.ballys.tech/excite/native/applications/personalised-lobby-ts-lambda-v3/blob/75c6ff00142d6935e18342f64345d97b3229adb6/README.md#L347-L355). This is tied into an automated versioning and changelog generation: a tool (@jscutlery/semver) reads commit messages to bump version numbers for each package (each Lambda and the library has its own version) and generate **CHANGELOG.md** files. For example, the OSClient library’s changelog shows feature additions and fixes with references to internal tickets[GitHub](https://gitlab.ballys.tech/excite/native/applications/personalised-lobby-ts-lambda-v3/blob/75c6ff00142d6935e18342f64345d97b3229adb6/libs/OSClient/CHANGELOG.md#L26-L34)[GitHub](https://gitlab.ballys.tech/excite/native/applications/personalised-lobby-ts-lambda-v3/blob/75c6ff00142d6935e18342f64345d97b3229adb6/libs/OSClient/CHANGELOG.md#L36-L44).
    - **Semantic Release** – The CI pipeline uses semantic-release (via the Nx plugin) to cut new versions and publish changelogs for each function and the library. Each Lambda function’s package.json version is updated independently (since they are independent deployable units) and a combined release may publish multiple packages. Versions are also used to tag Docker images (see below).
    - **Yarn Workspaces** – The monorepo is managed with Yarn workspaces and Nx, which means dependencies are hoisted and projects (functions and libs) are listed in the root `package.json`. The OSClient library is referenced as `os-client` dependency in the Lambdas via the workspace (so when you run `yarn`, it links the local `libs/OSClient` package into node_modules for the functions).
- **Docker (Containerization)** – The project supports containerized builds of the Lambdas. Each function can be packaged as a Docker image (Node.js 20 on RHEL9 base) for deployment or local testing. A multi-stage Dockerfile is included for building the functions using Nx and then running them on the minimal runtime image[GitHub](https://gitlab.ballys.tech/excite/native/applications/personalised-lobby-ts-lambda-v3/blob/75c6ff00142d6935e18342f64345d97b3229adb6/README.md#L103-L111). The repository provides Nx targets to build and run these images (e.g. `yarn docker:build` to build all Lambdas’ images, `yarn nx run-docker <function-name>` to run one locally in a container). This ensures parity between local testing and the production runtime environment. In CI, after code is versioned, a pipeline job builds Docker images for each function tagged with its semantic version, and pushes them to an internal Docker registry (Artifactory)[GitHub](https://gitlab.ballys.tech/excite/native/applications/personalised-lobby-ts-lambda-v3/blob/75c6ff00142d6935e18342f64345d97b3229adb6/README.md#L119-L127)[GitHub](https://gitlab.ballys.tech/excite/native/applications/personalised-lobby-ts-lambda-v3/blob/75c6ff00142d6935e18342f64345d97b3229adb6/README.md#L113-L117). *Note:* Currently the SAM deployment uses ZIP packages, but the Docker images are prepared for potential use (either in local development with tools like `sam local` or future deployment strategies).
- **Configuration and Secrets** – Configuration is mostly done via environment variables. For local usage, there are example environment files (e.g., `env_example.json`, `env.eu.json.example`) that list required variables[GitHub](https://gitlab.ballys.tech/excite/native/applications/personalised-lobby-ts-lambda-v3/blob/75c6ff00142d6935e18342f64345d97b3229adb6/env_example.json#L2-L9)[GitHub](https://gitlab.ballys.tech/excite/native/applications/personalised-lobby-ts-lambda-v3/blob/75c6ff00142d6935e18342f64345d97b3229adb6/env.eu.json.example#L8-L16). Key configuration includes:
    - **OpenSearch connection**: `HOST` (OpenSearch endpoint URL), `OS_USER` and `OS_PASS` (credentials for Basic Auth to OS, if required).
    - **Contentful credentials**: `CONTENTFUL_SPACE_LOCALE` (default locale of the Contentful space, e.g. "en-GB"), `CONTENTFUL_ACCESS_TOKEN` (for Contentful API), `CONTENTFUL_ENVIRONMENT` (Contentful environment, e.g. "dev" or "master"), `CONTENTFUL_SIGNING_SECRET` (to verify webhooks from Contentful) and `SPACE_ID` (Contentful space ID)[GitHub](https://gitlab.ballys.tech/excite/native/applications/personalised-lobby-ts-lambda-v3/blob/75c6ff00142d6935e18342f64345d97b3229adb6/template.yaml#L402-L410).
    - **Other**: `REGION` (e.g. "EU" vs "NA" to distinguish regional data), `EXECUTION_ENVIRONMENT` (e.g. "staging" or "production" – used within code to adjust behavior if needed). These variables are injected into Lambdas via the SAM template, which pulls values from AWS SSM Parameter Store at deploy time[GitHub](https://gitlab.ballys.tech/excite/native/applications/personalised-lobby-ts-lambda-v3/blob/75c6ff00142d6935e18342f64345d97b3229adb6/template.yaml#L48-L56)[GitHub](https://gitlab.ballys.tech/excite/native/applications/personalised-lobby-ts-lambda-v3/blob/75c6ff00142d6935e18342f64345d97b3229adb6/template.yaml#L50-L54) (keeping secrets out of source code). For local runs, developers supply these in `env.json`.

Overall, the tech stack is **TypeScript/Node.js** on AWS Lambda with an **Nx monorepo** build system, integrated with **Contentful CMS** and **OpenSearch**. It embraces Infrastructure-as-Code (SAM/CloudFormation), CI/CD with semantic versioning, and best practices like layered architecture and local emulation via Docker/SAM CLI.

## High-Level Architecture

At a high level, the system architecture can be viewed in two parts: **(1) Content Ingestion** and **(2) Content Delivery**. The diagram below illustrates the components and data flow:

```mermaid
flowchart LR
    %% Define nodes
    subgraph Content Management (CMS)
        CF[Contentful CMS]:::ext
    end
    subgraph AWS Cloud
        APIGW(API Gateway)
        LAMBDA[[Lambda Functions (Personalised Lobby API)]]
        OS[(OpenSearch Indices)]
        CFWebhook[[PostHistoricalGameTitles Lambda]]
    end
    subgraph User
        FE[Frontend Client (Web/App)]:::ext
    end
    %% Define styles for external
    classDef ext fill:#fffbcc,stroke:#333,stroke-width:1px,color:#000;
    %% Draw connections
    CF -- "Content entries\n(published via API or ETL)" --> OS
    CF -- "Webhook: content archived\nor removed" --> CFWebhook
    CFWebhook -- "Index update\n(archive index)" --> OS
    FE -- "HTTPS requests" --> APIGW
    APIGW -- "Invoke" --> LAMBDA
    LAMBDA -- "Query data" --> OS
    LAMBDA -- "Response" --> APIGW
    APIGW -- "JSON response" --> FE

```

**Content Ingestion**: Contentful is the source of content (game information, lobby structure such as sections, etc.). Periodically or on certain events, this content is indexed into OpenSearch. In practice, a separate pipeline or process (not fully shown in this repo) takes newly published Contentful data and writes it into the OpenSearch indices that the Lambdas query. This could be a synchronization job or manual triggers. Additionally, a special **Contentful Webhook Lambda** (the `PostHistoricalGameTitlesHandlerFunction`) handles specific events: when a game or site-specific game entry is archived or unpublished in Contentful, Contentful sends an HTTP POST to this Lambda (secured by a signing secret)[GitHub](https://gitlab.ballys.tech/excite/native/applications/personalised-lobby-ts-lambda-v3/blob/75c6ff00142d6935e18342f64345d97b3229adb6/functions/PostHistoricalGameTitlesHandlerFunction/app.ts#L270-L278)[GitHub](https://gitlab.ballys.tech/excite/native/applications/personalised-lobby-ts-lambda-v3/blob/75c6ff00142d6935e18342f64345d97b3229adb6/functions/PostHistoricalGameTitlesHandlerFunction/app.ts#L294-L303). The Lambda verifies the request signature and then fetches the affected content entry from Contentful’s API[GitHub](https://gitlab.ballys.tech/excite/native/applications/personalised-lobby-ts-lambda-v3/blob/75c6ff00142d6935e18342f64345d97b3229adb6/functions/PostHistoricalGameTitlesHandlerFunction/app.ts#L272-L280)[GitHub](https://gitlab.ballys.tech/excite/native/applications/personalised-lobby-ts-lambda-v3/blob/75c6ff00142d6935e18342f64345d97b3229adb6/functions/PostHistoricalGameTitlesHandlerFunction/app.ts#L320-L328). If the content type is a game or siteGame, and it was archived or turned into a draft, the Lambda will **update the OpenSearch indices** accordingly – for example, moving that game’s data to an “archived games” index for historical reference[GitHub](https://gitlab.ballys.tech/excite/native/applications/personalised-lobby-ts-lambda-v3/blob/75c6ff00142d6935e18342f64345d97b3229adb6/functions/PostHistoricalGameTitlesHandlerFunction/app.ts#L326-L335)[GitHub](https://gitlab.ballys.tech/excite/native/applications/personalised-lobby-ts-lambda-v3/blob/75c6ff00142d6935e18342f64345d97b3229adb6/functions/PostHistoricalGameTitlesHandlerFunction/app.ts#L159-L168). This ensures that any game removal is reflected in the search index (so that removed games don’t appear in user-facing results, and their titles can be served from the archive if needed). Aside from this webhook-based ingestion for removals, other content updates (like new games or changes in section assignments) are likely handled by separate data pipelines (e.g., periodic sync jobs or other Lambdas not detailed here). The key point is that **OpenSearch becomes the consolidated data store** that holds all content needed to build the lobby – both current and some historical data – derived from the Contentful CMS.

**Content Delivery**: The front-end (client application) calls the API Gateway endpoints (over HTTPS) to retrieve lobby data. API Gateway is configured (via SAM) with routes that map to corresponding Lambda integrations. When a request comes in (say, `/sites/royalcasino/platform/desktop/navigation`), API Gateway invokes the specific Lambda (e.g., GetNavigationFunction) and passes along path parameters, query parameters, etc. The Lambda will execute, typically performing the following steps:

1. **Input Validation & Parameter Handling**: The Lambda extracts identifiers from the request (e.g., site name, platform, possibly a member ID if provided as a query param or from auth context). It uses utility functions to normalize or validate these (for instance, ensuring the site name matches expected format, patching known aliases, etc.). If required parameters are missing or invalid, the Lambda may immediately return an error (e.g., 400 Bad Request). The lambdas have standardized error handling – for example, any thrown error is caught and translated into a JSON response with an error code and appropriate HTTP status[GitHub](https://gitlab.ballys.tech/excite/native/applications/personalised-lobby-ts-lambda-v3/blob/75c6ff00142d6935e18342f64345d97b3229adb6/functions/GetGamesFunction/README.md#L14-L23).
2. **OpenSearch Query**: The Lambda constructs a query to OpenSearch, often using the shared OSClient library helpers. Each endpoint targets specific OpenSearch **indices/aliases**. For example, the “get games in a section” endpoint will query an index that stores relationships of games to sections. Many indices and aliases are defined (some visible in the OSClient constants[GitHub](https://gitlab.ballys.tech/excite/native/applications/personalised-lobby-ts-lambda-v3/blob/75c6ff00142d6935e18342f64345d97b3229adb6/libs/OSClient/index.ts#L10-L19)[GitHub](https://gitlab.ballys.tech/excite/native/applications/personalised-lobby-ts-lambda-v3/blob/75c6ff00142d6935e18342f64345d97b3229adb6/libs/OSClient/index.ts#L20-L28)) – such as `ALL_SECTIONS_SHARED_READ_ALIAS`, `GAMES_INDEX_V2_ALIAS`, `ML_GAMES_RECOMMENDER_INDEX_ALIAS`, etc. These correspond to different data sets:
    - **Content indices**: e.g., Sections, Games, Navigation, Layouts (views) – populated from Contentful.
    - **ML indices**: e.g., “Suggested for you”, “Recently played”, “Because you played” – these likely store precomputed recommendations per user or site, produced by a Machine Learning service or job.
    - **Historical index**: e.g., Archived games – storing titles or info of games no longer active.
    
    The Lambda will perform one or multiple OpenSearch queries depending on the logic. For instance, the **GetGamesFunction** (for section games) first queries the Sections index to get the type of the section (to know if it’s a personalized section)[GitHub](https://gitlab.ballys.tech/excite/native/applications/personalised-lobby-ts-lambda-v3/blob/75c6ff00142d6935e18342f64345d97b3229adb6/functions/GetGamesFunction/README.md#L16-L24). If it’s a normal section, it then queries the Games index for that section’s games. If it’s a “personalized” section (like “Suggested for You”), the Lambda will require a user identifier and will query an ML recommendations index for that user[GitHub](https://gitlab.ballys.tech/excite/native/applications/personalised-lobby-ts-lambda-v3/blob/75c6ff00142d6935e18342f64345d97b3229adb6/functions/GetGamesFunction/README.md#L42-L50)[GitHub](https://gitlab.ballys.tech/excite/native/applications/personalised-lobby-ts-lambda-v3/blob/75c6ff00142d6935e18342f64345d97b3229adb6/functions/GetGamesFunction/README.md#L56-L64), then use those results to fetch actual game details from the Games index. The logic can be quite involved – for example, in GetGamesFunction, as illustrated by its internal flow diagram[GitHub](https://gitlab.ballys.tech/excite/native/applications/personalised-lobby-ts-lambda-v3/blob/75c6ff00142d6935e18342f64345d97b3229adb6/functions/GetGamesFunction/README.md#L11-L20)[GitHub](https://gitlab.ballys.tech/excite/native/applications/personalised-lobby-ts-lambda-v3/blob/75c6ff00142d6935e18342f64345d97b3229adb6/functions/GetGamesFunction/README.md#L25-L33), the Lambda handles up to three personalization scenarios (Suggested, Because You Played, Recently Played) and has fallback logic if the ML service returns no results (such as defaulting to a non-personalized list)[GitHub](https://gitlab.ballys.tech/excite/native/applications/personalised-lobby-ts-lambda-v3/blob/75c6ff00142d6935e18342f64345d97b3229adb6/functions/GetGamesFunction/README.md#L43-L51)[GitHub](https://gitlab.ballys.tech/excite/native/applications/personalised-lobby-ts-lambda-v3/blob/75c6ff00142d6935e18342f64345d97b3229adb6/functions/GetGamesFunction/README.md#L67-L75). Other Lambdas might have simpler flows (e.g., GetNavigation just fetches a navigation document by site name, GetAllGamesSearch might do a search query across the games index, etc.). All queries use the OpenSearch client with credentials from the environment to securely access the cluster.
    
3. **Data Processing**: After retrieving data from OpenSearch, the Lambda will process/format it into the response shape expected by clients. This may involve merging multiple query results, sorting or slicing lists, and mapping field names to a client-friendly format. For example, a Lambda might enrich raw game documents with additional fields or filter out certain entries (like removing games tagged as “exclude_recently_played” in a recently played query)[GitHub](https://gitlab.ballys.tech/excite/native/applications/personalised-lobby-ts-lambda-v3/blob/75c6ff00142d6935e18342f64345d97b3229adb6/functions/GetGamesFunction/README.md#L72-L76)[GitHub](https://gitlab.ballys.tech/excite/native/applications/personalised-lobby-ts-lambda-v3/blob/75c6ff00142d6935e18342f64345d97b3229adb6/functions/GetGamesFunction/README.md#L73-L81). The OSClient library provides helper functions for building the final payload (such as `gamesPayloadBySiteGame` or `orderedPayload` to sort and format results consistently[GitHub](https://gitlab.ballys.tech/excite/native/applications/personalised-lobby-ts-lambda-v3/blob/75c6ff00142d6935e18342f64345d97b3229adb6/libs/OSClient/index.ts#L148-L156)).
4. **Response**: The Lambda returns an HTTP response (via AWS API Gateway integration). On success, this is typically a JSON body containing the requested data (e.g., an array of games, or an object with section details), with HTTP status 200. On error or if something is not found, the Lambdas strive to return a useful status code and message. For instance, if a user requests a personalized section without being authenticated, the function may return a 400 error indicating authentication is required (in logs, this was humorously referred to as “BadWolf” for missing auth)[GitHub](https://gitlab.ballys.tech/excite/native/applications/personalised-lobby-ts-lambda-v3/blob/75c6ff00142d6935e18342f64345d97b3229adb6/functions/GetGamesFunction/README.md#L94-L102). If a requested entity is not found (e.g., section ID doesn’t exist), a 404 might be returned. Some endpoints intentionally return an empty list with 200 if no content – for example, if a section has no games or none of the queries returned results, the response will be a 200 with an empty array rather than an error, indicating “no content available” is a valid scenario[GitHub](https://gitlab.ballys.tech/excite/native/applications/personalised-lobby-ts-lambda-v3/blob/75c6ff00142d6935e18342f64345d97b3229adb6/functions/GetGamesFunction/README.md#L22-L29).

The API Gateway then propagates that response back to the client. The front-end receives a JSON payload that it can use to render the lobby UI. Because the content is fetched on-demand via these Lambdas, any updates in Contentful (once indexed to OpenSearch) are reflected in near real-time on the user’s next API call (for example, adding a new game to a section in Contentful will cause that game to appear in the API’s output for that section after the next content sync).

### Request–Response Flow Example

To cement understanding, consider a typical use-case: **Loading the Lobby Page** for a user on a given site. The front-end might make a series of API calls such as:

- `GET /sites/{sitename}/platform/{platform}/navigation` – to fetch navigation categories or menu items.
- `GET /sites/{sitename}/platform/{platform}/view/{viewslug}` – to fetch the high-level sections on a particular “view” (page). For example, `viewslug` might be "homepage" indicating the main lobby view. This could return a list of sections (like "Jackpot Games", "Suggested for You", etc.) with their metadata.
- For each section that needs data (or for certain sections that load on demand), calls like:
    - `GET /sites/{sitename}/platform/{platform}/view/{viewslug}/sections/{sectionId}/sitegames` – returns the list of games for that section (if the section is personalized and the user is not logged in, this might return an error or require a different handling).
    - If the section is a personalized category and the user is logged in (with a member identifier provided), the above call will include personalized results. If not logged in, the call might be skipped or an alternate endpoint is used (for example, the frontend might know not to call certain personal endpoints without auth).
- Some UIs might call specialized endpoints:
    - `GET /sites/{sitename}/platform/{platform}/recently-played` – to get a user’s recently played games (could be used to render a “Recently Played” carousel).
    - `GET /sites/{sitename}/platform/{platform}/suggested-for-you` – to get recommended games (if these aren’t already included via the main section call).
    - `GET /sites/{sitename}/platform/{platform}/minigames` – to get a list of “mini games” (perhaps a special category of games).
    - `GET /sites/{sitename}/platform/{platform}/games/{gameName}` – to fetch detailed info on a specific game (e.g., if user clicks for details or to launch a game).
    - `GET /sites/{sitename}/platform/{platform}/game-config/{gameName}` – to fetch configuration details for a game on that site (e.g., betting limits, feature flags for that game).
    - `GET /content/sites/{sitename}/platform/{platform}/search?query=...` – to search through all games (the path suggests a search endpoint under `/search`).
- If a user triggers a game exit event (for instance, closing a game), the front-end might call `GET /sites/{sitename}/platform/{platform}/gameskin/{gameSkin}/recommended-games-on-exit` – which would return a set of games recommended to the user as a next step (based on the game they were playing). This helps increase engagement by suggesting similar or relevant games.

The above calls map to the various Lambda functions described in the next section. The Lambdas collectively comprise the “Personalised Lobby API” which the frontend uses. Because each function is separate, they can be developed, tested, and deployed independently, though they share common logic via the OSClient library and are deployed as one stack.

## Repository Structure and Components

The project is structured to support many Lambda functions and shared code in a single repository (monorepo). The top-level layout includes:

- **`functions/`** – This directory contains one sub-folder per Lambda function (each implementing one API endpoint or a group of closely related endpoints). Each function folder is named with a descriptive function name, for example: `GetNavigationFunction`, `GetViewFunction`, `GetGamesFunction`, `GetRecentlyPlayedFunction`, `PostHistoricalGameTitlesHandlerFunction`, etc. Inside each function folder, you’ll typically find:
    - An **`app.ts`** (or `index.ts`) file which contains the main handler code (exporting `lambdaHandler` to be invoked by AWS). This is the entry point for the Lambda.
    - Optionally, a `lib/` folder with additional modules if the function’s logic is complex (to keep `app.ts` cleaner).
    - A `package.json` and `project.json` – specifying its own dependencies and Nx configuration (however, most runtime deps are shared and listed at the root, the individual package.json may mainly contain its name and version).
    - A `README.md` – documentation specific to that function, often describing its purpose and usage. (Many of these README files also provide instructions on how to add the function to the deployment template and how to invoke it locally.)
    - A `CHANGELOG.md` – auto-generated file listing changes (if semantic versioning has released updates for that function).
    - A `tests/` directory – containing unit tests (usually using Jest).
    - An `events/` directory – containing sample event JSON files to simulate typical inputs for local testing. For instance, `events/event.json` or region-specific ones like `event.eu.json` and `event.na.json` that represent API Gateway event payloads for EU or NA regions. These include example path parameters, etc., and can be used with `sam local invoke` to test the function.
    - Config files: each function has its own TypeScript config (`tsconfig.json`), and possibly Jest config (`jest.config.ts`) and ESLint config.
    
    All these Lambda function projects are defined in Nx, which knows how to build them (transpile TS to JS, bundle if needed) and run tests. The **naming convention** is that each function folder corresponds to a CloudFormation resource name and logically to an API endpoint. For example, `GetGamesFunction` corresponds to the API route to get games for a section; `GetAllGamesSearchFunction` corresponds to the “search all games” API, etc. The SAM template references these directories for the code of each function[GitHub](https://gitlab.ballys.tech/excite/native/applications/personalised-lobby-ts-lambda-v3/blob/75c6ff00142d6935e18342f64345d97b3229adb6/template.yaml#L40-L48)[GitHub](https://gitlab.ballys.tech/excite/native/applications/personalised-lobby-ts-lambda-v3/blob/75c6ff00142d6935e18342f64345d97b3229adb6/template.yaml#L94-L102) and ties them to specific URL paths.
    
- **`libs/OSClient`** – This is the shared library (marked as a `type: lib` in Nx) containing the OpenSearch client and utility code. It has submodules:
    - `lib/osClient.ts` which likely creates and configures the OpenSearch client instance (using host, user, pass from environment) and exports a `getClient()` method to obtain an `IClient` (OpenSearch client interface)[GitHub](https://gitlab.ballys.tech/excite/native/applications/personalised-lobby-ts-lambda-v3/blob/75c6ff00142d6935e18342f64345d97b3229adb6/libs/OSClient/index.ts#L1-L8).
    - `lib/constants.ts` defining all the index names and aliases used by the queries[GitHub](https://gitlab.ballys.tech/excite/native/applications/personalised-lobby-ts-lambda-v3/blob/75c6ff00142d6935e18342f64345d97b3229adb6/libs/OSClient/index.ts#L10-L19)[GitHub](https://gitlab.ballys.tech/excite/native/applications/personalised-lobby-ts-lambda-v3/blob/75c6ff00142d6935e18342f64345d97b3229adb6/libs/OSClient/index.ts#L20-L28).
    - `lib/utils.ts` and `lib/personalisation.ts` which hold a lot of the query-building and business logic for personalized sections (like functions to get ML suggested games, handle “because you played” logic, map sorting options to OpenSearch fields, etc.)[GitHub](https://gitlab.ballys.tech/excite/native/applications/personalised-lobby-ts-lambda-v3/blob/75c6ff00142d6935e18342f64345d97b3229adb6/libs/OSClient/index.ts#L126-L135)[GitHub](https://gitlab.ballys.tech/excite/native/applications/personalised-lobby-ts-lambda-v3/blob/75c6ff00142d6935e18342f64345d97b3229adb6/libs/OSClient/index.ts#L132-L140).
    - `lib/localization.ts` for handling the content localization logic (ensuring the right locale is used for queries and for picking localized fields from Contentful data)[GitHub](https://gitlab.ballys.tech/excite/native/applications/personalised-lobby-ts-lambda-v3/blob/75c6ff00142d6935e18342f64345d97b3229adb6/libs/OSClient/README.md#L35-L44)[GitHub](https://gitlab.ballys.tech/excite/native/applications/personalised-lobby-ts-lambda-v3/blob/75c6ff00142d6935e18342f64345d97b3229adb6/libs/OSClient/README.md#L52-L60). This handles the nuance that Contentful content is default-localized to a region (e.g., en-GB for EU) and might have overrides for specific locales; the code ensures queries ask for the correct locale (for example, adding locale suffixes to field names in queries) and that responses are correctly mapped.
    - Other utility modules: e.g., `errors.ts` (defines error types and logging of errors), `logger.ts` (structured logging), `requestUtils.ts` (helpers for extracting hits from OpenSearch responses), `gamesPayloads.ts` (functions to format the final game objects in the response payload), etc.
    - `sharedInterfaces/` – TypeScript interfaces and types shared between lambdas, defining structures like Game, Section, responses, etc., to ensure consistency.
    
    The OSClient library is packaged as a Lambda Layer. The SAM template includes an `OSClientLayer` resource (not fully shown in excerpts above, but referenced in Metadata of each function) and attaches it to each Lambda. During deployment, this means the code in `libs/OSClient` is built and zipped as a layer. The layer’s content (node_modules) includes the `os-client` module. At runtime, AWS mounts the layer so that `/opt/nodejs/node_modules/os-client` is available. The Lambdas import from this path (as shown in the GetCategories/Navigation README)[GitHub](https://gitlab.ballys.tech/excite/native/applications/personalised-lobby-ts-lambda-v3/blob/75c6ff00142d6935e18342f64345d97b3229adb6/functions/GetNavigationFunction/README.md#L10-L18). Locally, thanks to a path mapping in tsconfig, that import is resolved to the source code, so developers don’t need to change import statements – it “just works” in both environments.
    
- **Root configuration and scripts**:
    - The `template.yaml` at root is the AWS SAM template defining all the Lambdas, API Gateway, layer, and related config (like environment variables and permissions). It’s a critical piece of the infrastructure-as-code. Each function appears in this template with its configuration. For instance, below is a snippet for **GetGamesFunction** showing its API event configuration and environment vars[GitHub](https://gitlab.ballys.tech/excite/native/applications/personalised-lobby-ts-lambda-v3/blob/75c6ff00142d6935e18342f64345d97b3229adb6/template.yaml#L112-L119):
        
        ```yaml
        Events:
            GetGames:
                Type: Api
                Properties:
                    Path: /sites/{sitename}/platform/{platform}/view/{viewslug}/sections/{sectionid}/sitegames
                    Method: get
                    RestApiId: !Ref LobbyApi
        
        ```
        
        All routes follow a similar pattern under `/sites/{sitename}/platform/{platform}/...` except a couple like search and historical titles. The template also sets `BuildMethod: makefile` for each function[GitHub](https://gitlab.ballys.tech/excite/native/applications/personalised-lobby-ts-lambda-v3/blob/75c6ff00142d6935e18342f64345d97b3229adb6/template.yaml#L116-L119), which instructs SAM to use the Nx build process (via a Makefile target) to compile the TypeScript (rather than using its own heuristic). This is why each function is built with esbuild and not by SAM’s default (which might use `npm install` etc. – here we override it to ensure Nx handles the build).
        
    - Nx config files: `nx.json` (defining Nx tasks and defaults) and possibly `workspace.json` or project json files as noted. The Nx tasks runner is configured to run builds, tests, lint, etc., and custom tasks like `docker`, `run-docker`, `version`, `changelog` as seen in `nx.json`[GitHub](https://gitlab.ballys.tech/excite/native/applications/personalised-lobby-ts-lambda-v3/blob/75c6ff00142d6935e18342f64345d97b3229adb6/nx.json#L26-L35)[GitHub](https://gitlab.ballys.tech/excite/native/applications/personalised-lobby-ts-lambda-v3/blob/75c6ff00142d6935e18342f64345d97b3229adb6/nx.json#L64-L73). Notably, running `nx build <function>` will output a bundled `app.cjs` for that Lambda in `dist/<function>`, and `nx test <function>` runs its Jest tests.
    - Utility scripts: There is a `scripts/` directory with helpful automation. For example, `update-dependencies.js` ensures that when versions bump, inter-dependencies (like each function depending on `os-client` library of a certain version) are kept in sync to avoid mismatches. There are also scripts to validate project naming and sync project versions (to orchestrate multi-package releases).
    - Top-level **README.md** – provides an overview of the project, quick start for installation, and developer notes (some of which were referenced in building this guide). It describes how to set up AWS CLI with SSO, how to add a new Lambda using an internal template tool, project structure, and Docker usage for building images. It also lists external references and guidelines for commit messages[GitHub](https://gitlab.ballys.tech/excite/native/applications/personalised-lobby-ts-lambda-v3/blob/75c6ff00142d6935e18342f64345d97b3229adb6/README.md#L335-L344).

Now let’s summarize the **core Lambda functions** present in this codebase and their roles:

- **GetNavigationFunction** – *Endpoint:* `GET /sites/{sitename}/platform/{platform}/navigation` – Returns the **navigation structure** for the specified site/platform. Essentially, this provides a list of top-level categories or menu items that the frontend should display (for example, categories like *Casino*, *Slots*, *Live Casino*, etc., depending on the venture). The Lambda likely queries an OpenSearch index that contains navigation entries (possibly built from Contentful’s navigation model). The output is typically a list of categories with their names and possibly links or IDs. This function ensures a site’s navigation can be managed via CMS and delivered quickly to the client.
- **GetViewFunction** – *Endpoint:* `GET /sites/{sitename}/platform/{platform}/view/{viewslug}` – Retrieves a **“View”** (which we can interpret as a page or screen configuration). In the context of the lobby, a “view” corresponds to a page that contains multiple sections. For example, a “Home” view might contain sections like “Jackpot Games”, “Recommended for You”, “Recently Played” etc. Given a `viewslug` (which identifies the view/page, e.g. “home”, “promotions”), this function returns the list of sections (and possibly some metadata about each section) for that view. The client can then know which sections to display in that page. The Lambda likely queries a “layouts” or “views” index for the structure of that view. The result could include section identifiers or slugs which then can be used to fetch the content of each section (either via subsequent calls or included if the view index already has some content). It acts as a high-level aggregator of sections. In the SAM template, this function’s event is oddly named “GetSections” and path includes “/view/{viewslug}”[GitHub](https://gitlab.ballys.tech/excite/native/applications/personalised-lobby-ts-lambda-v3/blob/75c6ff00142d6935e18342f64345d97b3229adb6/template.yaml#L84-L92) – which suggests it returns sections for the given view. (In earlier docs it’s referred to as “get-sections” function.)
- **GetSectionViewFunction** – *Endpoint:* `GET /sites/{sitename}/platform/{platform}/section/{sectionslug}` – Retrieves details for a specific **Section** (by slug or identifier). This can be used to get metadata about one section (for example, the section’s title, description, layout type, etc.). It might also include a list of items, but given there is a separate GetGamesFunction for section games, this function might focus on the section’s static content. One use-case could be a scenario where the front-end loads one section at a time (perhaps for a modal or a smaller widget). The Lambda likely queries the OpenSearch sections index for a section entry by its slug. For instance, if `sectionslug` is “jackpot-games”, it returns info about the “Jackpot Games” section (but not necessarily the games themselves, which come from GetGamesFunction by section ID). Essentially, **GetSectionView** provides *contextual or descriptive data about a section*.
- **GetGamesFunction** – *Endpoint:* `GET /sites/{sitename}/platform/{platform}/view/{viewslug}/sections/{sectionid}/sitegames` – Returns the **list of games for a given section** on a given view. This is one of the central functions, as it delivers the actual game entries the user will see in that section. It uses the section ID (likely a Contentful entry ID or some numeric ID) to query the OpenSearch index that links sections to games. The output is an array of games, each with attributes like title, image, game ID, etc. Importantly, this function contains logic to handle different section types:
    - If the section is a standard (non-personalized) section (e.g., “New Games” which is same for everyone), the function simply queries the index for that section’s games and returns them (possibly sorted or limited to a certain number).
    - If the section is personalized (Contentful might mark it as such, e.g., a section of type “Recommended for You”), the function will attempt to personalize the results. It will require a user context – likely the user’s ID or a member token is expected (in the current design, a `member` query parameter might be included, or the gateway might pass an authenticated user ID). If no user is provided for a personalized section, the function responds with an error (HTTP 400) because it cannot fulfill a personalized request without a user[GitHub](https://gitlab.ballys.tech/excite/native/applications/personalised-lobby-ts-lambda-v3/blob/75c6ff00142d6935e18342f64345d97b3229adb6/functions/GetGamesFunction/README.md#L94-L102). If user is provided, it queries the appropriate ML index (for suggested games, or recently played, etc., depending on section category) and then fetches the corresponding game details. The result is a personalized list for that user. If the ML data is empty (user is new, or no games to recommend), the function has fallback logic to either return an empty list or default content (e.g., a default list of popular games)[GitHub](https://gitlab.ballys.tech/excite/native/applications/personalised-lobby-ts-lambda-v3/blob/75c6ff00142d6935e18342f64345d97b3229adb6/functions/GetGamesFunction/README.md#L45-L53).
    
    This function also standardizes that if no games are found, it returns an empty list with status 200 (rather than an error)[GitHub](https://gitlab.ballys.tech/excite/native/applications/personalised-lobby-ts-lambda-v3/blob/75c6ff00142d6935e18342f64345d97b3229adb6/functions/GetGamesFunction/README.md#L24-L31) – meaning “no content in this section” is not exceptional. Because this function interacts with multiple indices and decision branches, it is one of the more complex pieces of the codebase. It heavily utilizes OSClient utilities like `checkAndGuardSectionType` (to enforce auth for personal sections) and `handlePersonalizedGames` (to orchestrate the personalized retrieval flows) – these are defined in the `personalisation.ts` helper[GitHub](https://gitlab.ballys.tech/excite/native/applications/personalised-lobby-ts-lambda-v3/blob/75c6ff00142d6935e18342f64345d97b3229adb6/libs/OSClient/index.ts#L132-L140)[GitHub](https://gitlab.ballys.tech/excite/native/applications/personalised-lobby-ts-lambda-v3/blob/75c6ff00142d6935e18342f64345d97b3229adb6/libs/OSClient/index.ts#L134-L142). For a new developer, understanding **GetGamesFunction** is key to understanding how personalization is implemented.
    
- **GetSuggestedForYouFunction** – *Endpoint:* `GET /sites/{sitename}/platform/{platform}/suggested-for-you` – Returns a list of games **recommended for the user** (“Suggested for You”). This appears to be a separate endpoint that likely provides similar data to a “Suggested” section, but possibly meant to be called independently. It might be used to load a personalized carousel of suggestions on the homepage. Internally, this function will query the ML “games recommender” index (which stores recommended game IDs for a user)[GitHub](https://gitlab.ballys.tech/excite/native/applications/personalised-lobby-ts-lambda-v3/blob/75c6ff00142d6935e18342f64345d97b3229adb6/functions/GetGamesFunction/README.md#L43-L51), then fetch those games from the main games index, and return them. If the user is not logged in or has no recommendations, it might return an empty list or a default list. The separation of this endpoint from GetGamesFunction suggests that the front-end can retrieve personalized suggestions without needing the whole section context, or maybe it was added to optimize performance (fetch suggestions in parallel to other content). In any case, it serves the **“Suggested for you” content** on the lobby.
- **GetRecentlyPlayedFunction** – *Endpoint:* `GET /sites/{sitename}/platform/{platform}/recently-played` – Provides the list of games the user recently played (for the given site). This likely reads from an ML or tracking index (named something like “recently_played_games” per user). If a user has played games in the past, the index would have those game IDs; the Lambda fetches them and then retrieves those games’ details from the game index. This powers a “Recently Played” section on the UI so users can quickly resume or see what they last engaged with. If the user is new or hasn’t played anything, it may return an empty list. The code for this would overlap with part of GetGamesFunction’s personalized branch but now exposed as its own endpoint (as noted in a changelog entry: *recently played separate endpoint*[GitHub](https://gitlab.ballys.tech/excite/native/applications/personalised-lobby-ts-lambda-v3/blob/75c6ff00142d6935e18342f64345d97b3229adb6/libs/OSClient/CHANGELOG.md#L5-L13)). This implies originally recently-played was only accessible as a personalized section via GetGamesFunction, but a dedicated endpoint was later introduced (perhaps to allow the front-end to fetch it on demand).
- **GetMiniGamesFunction** – *Endpoint:* `GET /sites/{sitename}/platform/{platform}/minigames` – Retrieves a list of **“mini games”**. Mini games likely refer to a subset of games (maybe side games or quick-play games) that are categorized differently in Contentful. This function will query an index or filter games by a flag indicating they are mini-games. For instance, Contentful might mark mini-games with a tag, or they reside in a specific section. The Lambda could either query a dedicated “minigames” index or query the main games index with a filter for `gameType = "mini"`, etc. The output is a list of mini game entries (with similar structure to normal games). This allows the front-end to populate a section or menu with mini games separately from the main catalog.
- **GetAllGamesSearchFunction** – *Endpoint:* `GET /content/sites/{sitename}/platform/{platform}/search?query=<term>` – Provides a **search** over all games for the given site and platform. This endpoint likely powers a search bar where users can type a game name or keyword. The Lambda takes the query string (e.g., “poker”) and runs a search on the OpenSearch games index across relevant fields (like game title, keywords). It may leverage OpenSearch’s full-text search and possibly aggregations (for example, to filter by categories). The result is a list of games matching the query. The reason the path includes `/content/` might be to distinguish it or version it differently, but effectively it’s searching within the site’s content. The implementation probably uses the OpenSearch client’s search method with a wildcard or match query. Because search can return many results, this Lambda has a higher timeout set (60 seconds) in the template[GitHub](https://gitlab.ballys.tech/excite/native/applications/personalised-lobby-ts-lambda-v3/blob/75c6ff00142d6935e18342f64345d97b3229adb6/template.yaml#L234-L242), and likely supports pagination. Indeed, documentation in the GetGamesFunction README discusses how deep pagination might require using OpenSearch “search after” techniques for efficiency[GitHub](https://gitlab.ballys.tech/excite/native/applications/personalised-lobby-ts-lambda-v3/blob/75c6ff00142d6935e18342f64345d97b3229adb6/functions/GetGamesFunction/README.md#L122-L131)[GitHub](https://gitlab.ballys.tech/excite/native/applications/personalised-lobby-ts-lambda-v3/blob/75c6ff00142d6935e18342f64345d97b3229adb6/functions/GetGamesFunction/README.md#L140-L149) – this is likely relevant to the search function. The function might accept `from` and `size` parameters (or automatically page through large result sets) to support pagination of search results. It ensures players can look up any game and find it quickly via the backend.
- **GetGameInfoFunction** – *Endpoint:* `GET /sites/{sitename}/platform/{platform}/games/{gamename}` – Fetches detailed **information about a single game**. Given a game identifier (possibly a slug or name), this returns its full details – such as description, images, provider, attributes, etc., as well as maybe site-specific info (like if it’s enabled on that site). This Lambda will query the game index for the game entry (each game likely has a unique ID and also linked site info). In the OSClient, we see references to functions like `getGameHits` and `getSiteGameHits`[GitHub](https://gitlab.ballys.tech/excite/native/applications/personalised-lobby-ts-lambda-v3/blob/75c6ff00142d6935e18342f64345d97b3229adb6/libs/OSClient/index.ts#L56-L64) which suggests the data model: there might be separate documents for “Game” (global properties) and “SiteGame” (site-specific properties like visibility, bet limits). The GameInfo function might actually combine these: find the game by name or ID, and include any site-specific overrides. For example, if a game is not available in a region, that info could be part of siteGame data. This function ensures the frontend can display a game’s details page.
- **GetGameConfigFunction** – *Endpoint:* `GET /sites/{sitename}/platform/{platform}/game-config/{gamename}` – Retrieves **configuration data for a game** on that site. This is related to GameInfo but perhaps split out for performance or clarity. “Config” might include dynamic values needed to launch or display the game properly – for example, jackpot contribution settings, game identifiers needed by the game client, or toggles like “chat enabled” or “sash (badge) info” on the game tile. Looking at the PostHistoricGameTitles code, the siteGame object contains fields such as `sash`, `chat`, `maxBet`, `minBet`, `howToPlayContent`, and visibility flags[GitHub](https://gitlab.ballys.tech/excite/native/applications/personalised-lobby-ts-lambda-v3/blob/75c6ff00142d6935e18342f64345d97b3229adb6/functions/PostHistoricalGameTitlesHandlerFunction/app.ts#L102-L111). These are likely part of what we call “game config.” So GetGameConfigFunction may return those fields (which are more operational/config in nature) for a given game and site. The GameConfig is separated because the front-end might load basic info first (via GameInfo) and then load config if needed (or vice versa). It might also allow certain calls to be cached differently. In implementation, this function queries perhaps the **siteGame index** directly for the given game and site, returning those properties.
- **GetPersonalisedExtraDataFunction** – *Endpoint:* `GET /sites/{sitename}/personalised-extra-data` – Provides any **additional personalized data** for the site that isn’t covered by the above endpoints. The absence of `{platform}` and other typical params suggests this might return something broad for the site (maybe not platform-specific, or platform is irrelevant for the data it provides). “Extra data” could include things like personalized marketing content, user-specific messages, or aggregated info (for example, “you have 5 unfinished missions”, etc., purely speculative). Given the context, one possibility is that this endpoint returns user-specific metadata that could be used across the site. Another possibility is that this was intended to supply any miscellaneous data for personalization experiments. In the codebase, `GetPersonalisedExtraDataFunction` likely queries a small index or a combination of things. Without more specifics in the docs, we can describe it generally: it is an endpoint reserved for **miscellaneous personalized content** not covered by the focused endpoints. A new developer might note its existence, but it likely shares patterns from other functions (checking user, querying some ML or content index).
- **GetRecommendedGamesOnExitFunction** – *Endpoint:* `GET /sites/{sitename}/platform/{platform}/gameskin/{gameskin}/recommended-games-on-exit` – Supplies **recommended games when a player exits a specific game**. The `{gameskin}` param probably identifies the exact game session or variant (game skin might mean the game identifier including variant). This function addresses a use-case: when a player closes or leaves a game, the system can suggest other games to try (possibly similar ones or ones that other players who played this game also enjoyed). The Lambda could use the `{gameskin}` to query a specialized ML index (maybe something like “because you played X” recommendations, as hinted by constants like `ML_BECAUSE_YOU_PLAYED_X_ALIAS`[GitHub](https://gitlab.ballys.tech/excite/native/applications/personalised-lobby-ts-lambda-v3/blob/75c6ff00142d6935e18342f64345d97b3229adb6/libs/OSClient/index.ts#L42-L45)). It may fetch a set of games related to that game and return them. Internally, if the user is known, it might cross with user preferences; if not, it might use general popularity of that game. This endpoint helps increase user engagement by cross-selling games at the moment of exit. For developers, it’s one of the personalized endpoints focusing on a specific input (the game just played).
- **GetBulkGameDataFunction** – *Endpoint:* `GET /sites/{sitename}/platform/{platform}/get-bulk-game-data` – Returns **data for multiple games in one call**. This likely expects a list of game IDs or names provided via query parameters (or perhaps in the request body if it were POST, but it’s GET – maybe comma-separated IDs in a query param). The purpose is to allow the client to fetch details for a batch of games efficiently, instead of calling GetGameInfo repeatedly for each game. For example, a section might have 50 games; rather than 50 calls, the front-end could call this once with all IDs. The Lambda then queries OpenSearch for all those games in one go (OpenSearch can retrieve multiple documents by IDs, or search by multiple keys). It then returns a collection of game data. This is especially useful for bulk updates or initial loads. The function has an increased timeout (40 seconds) in the template[GitHub](https://gitlab.ballys.tech/excite/native/applications/personalised-lobby-ts-lambda-v3/blob/75c6ff00142d6935e18342f64345d97b3229adb6/template.yaml#L342-L350), indicating it can handle larger loads. In usage, a developer might call it by providing something like `?ids=game1,game2,game3` or similar (the exact interface can be found in its README or code). It demonstrates how the system can be optimized for batch retrieval.
- **GetHistoricalGameTitlesFunction** – *Endpoint:* `GET /sites/{sitename}/game-historical-titles` – Provides a list of **historical game titles** for a site. This endpoint is related to games that have been removed or archived. Imagine a scenario where a game was once in the lobby and a user had it bookmarked or an old URL – instead of failing, the system might want to show a message “Game [Title] is no longer available.” To display that title, the system needs to know the name of the game ID even after it’s archived. That’s likely what this function serves: given possibly some input (or it might just list all archived games?), it returns the titles of historical (archived) games for that site. The README suggests it “format[s] list of game titles and serve it back to client”[GitHub](https://gitlab.ballys.tech/excite/native/applications/personalised-lobby-ts-lambda-v3/blob/75c6ff00142d6935e18342f64345d97b3229adb6/functions/GetHistoricalGameTitlesFunction/README.md#L3-L7). Possibly, the client passes a list of game IDs (that it could not find in active games) to this endpoint, and it responds with their titles or a mapping of ID to title. Or it might simply return all archived game titles (less likely, as that could be large). The implementation likely queries the **archived games index** in OpenSearch which contains entries of type `game` or `sitegame` that were archived (the PostHistoric lambda populates that index). It then extracts the names and returns them. This ensures user experience is graceful for content that has been removed. For a new developer, it’s important to note that archived content is handled differently (separate index and separate endpoints). This function pairs with the PostHistoricalGameTitlesHandlerFunction which writes to the archived index.
- **PostHistoricalGameTitlesHandlerFunction** – *Endpoint:* `POST /historical-game-titles-handler` – This is the **Contentful webhook handler** Lambda we discussed in the ingestion flow. It is not directly called by end-users, but by Contentful’s webhook system. Whenever a content editor archives or deletes a game (or site-specific game entry) in the CMS, Contentful triggers an HTTP POST to this endpoint with details of what changed. The Lambda verifies the request using the `x-contentful-signature` header and a secret[GitHub](https://gitlab.ballys.tech/excite/native/applications/personalised-lobby-ts-lambda-v3/blob/75c6ff00142d6935e18342f64345d97b3229adb6/functions/PostHistoricalGameTitlesHandlerFunction/app.ts#L270-L278)[GitHub](https://gitlab.ballys.tech/excite/native/applications/personalised-lobby-ts-lambda-v3/blob/75c6ff00142d6935e18342f64345d97b3229adb6/functions/PostHistoricalGameTitlesHandlerFunction/app.ts#L240-L248) to ensure it’s really from Contentful (this uses the Contentful Node toolkit’s request signing verification). After verification, it parses the event body to get the Contentful `sys.id` of the content that changed (the game or sitegame ID)[GitHub](https://gitlab.ballys.tech/excite/native/applications/personalised-lobby-ts-lambda-v3/blob/75c6ff00142d6935e18342f64345d97b3229adb6/functions/PostHistoricalGameTitlesHandlerFunction/app.ts#L284-L293). It ensures the event is from the master environment (so it doesn’t react to changes in dev environments)[GitHub](https://gitlab.ballys.tech/excite/native/applications/personalised-lobby-ts-lambda-v3/blob/75c6ff00142d6935e18342f64345d97b3229adb6/functions/PostHistoricalGameTitlesHandlerFunction/app.ts#L298-L305) and that the content type is one of the ones it cares about (GAME_V2 or SITEGAME_V2)[GitHub](https://gitlab.ballys.tech/excite/native/applications/personalised-lobby-ts-lambda-v3/blob/75c6ff00142d6935e18342f64345d97b3229adb6/functions/PostHistoricalGameTitlesHandlerFunction/app.ts#L304-L312). Then it uses the Contentful Management API (with the provided `CONTENTFUL_ACCESS_TOKEN`) to **fetch the full content entry** that was changed[GitHub](https://gitlab.ballys.tech/excite/native/applications/personalised-lobby-ts-lambda-v3/blob/75c6ff00142d6935e18342f64345d97b3229adb6/functions/PostHistoricalGameTitlesHandlerFunction/app.ts#L55-L64)[GitHub](https://gitlab.ballys.tech/excite/native/applications/personalised-lobby-ts-lambda-v3/blob/75c6ff00142d6935e18342f64345d97b3229adb6/functions/PostHistoricalGameTitlesHandlerFunction/app.ts#L320-L328). It determines if the entry is archived or a draft (unpublished) using helper functions `isArchived` and `isDraft`[GitHub](https://gitlab.ballys.tech/excite/native/applications/personalised-lobby-ts-lambda-v3/blob/75c6ff00142d6935e18342f64345d97b3229adb6/functions/PostHistoricalGameTitlesHandlerFunction/app.ts#L326-L334). If the entry is archived or unpublished, the Lambda will index that entry’s data into the **archived games OpenSearch index** (referred to by an alias `ARCHIVED_GAMES_WRITE_ALIAS`)[GitHub](https://gitlab.ballys.tech/excite/native/applications/personalised-lobby-ts-lambda-v3/blob/75c6ff00142d6935e18342f64345d97b3229adb6/functions/PostHistoricalGameTitlesHandlerFunction/app.ts#L326-L334). The code constructs either a `gameResponseBody` or `siteGameResponseBody` depending on content type to shape the data for indexing[GitHub](https://gitlab.ballys.tech/excite/native/applications/personalised-lobby-ts-lambda-v3/blob/75c6ff00142d6935e18342f64345d97b3229adb6/functions/PostHistoricalGameTitlesHandlerFunction/app.ts#L120-L128)[GitHub](https://gitlab.ballys.tech/excite/native/applications/personalised-lobby-ts-lambda-v3/blob/75c6ff00142d6935e18342f64345d97b3229adb6/functions/PostHistoricalGameTitlesHandlerFunction/app.ts#L74-L82). It then calls `opensearchClient.update(...)` to upsert this document into the archive index[GitHub](https://gitlab.ballys.tech/excite/native/applications/personalised-lobby-ts-lambda-v3/blob/75c6ff00142d6935e18342f64345d97b3229adb6/functions/PostHistoricalGameTitlesHandlerFunction/app.ts#L159-L168)[GitHub](https://gitlab.ballys.tech/excite/native/applications/personalised-lobby-ts-lambda-v3/blob/75c6ff00142d6935e18342f64345d97b3229adb6/functions/PostHistoricalGameTitlesHandlerFunction/app.ts#L169-L176). Essentially, it’s moving the content from the “live” index to an “archive” index (or adding it there). If the content was simply changed (not archived), the function currently might do nothing (it’s primarily focused on removals). The Lambda returns a status 200 with `{ updated: true }` if it did index something, or `{ updated: false }` if the conditions to index weren’t met[GitHub](https://gitlab.ballys.tech/excite/native/applications/personalised-lobby-ts-lambda-v3/blob/75c6ff00142d6935e18342f64345d97b3229adb6/functions/PostHistoricalGameTitlesHandlerFunction/app.ts#L326-L335). This endpoint allows the **GetHistoricalGameTitlesFunction** to later retrieve the names of archived games from the archive index, as discussed. For development, testing this requires simulating a Contentful webhook call with proper headers and payload, which is non-trivial but the verification can be bypassed if one uses known secrets.

Summarizing the functions, you can see they fall into categories:

- **Navigation/Layout**: GetNavigation, GetView, GetSectionView.
- **Game content**: GetGames (section games), GetMiniGames, GetAllGamesSearch.
- **Game detail**: GetGameInfo, GetGameConfig, GetBulkGameData.
- **Personalization**: GetSuggestedForYou, GetRecentlyPlayed, GetRecommendedGamesOnExit, GetPersonalisedExtraData.
- **Content Management helpers**: GetHistoricalGameTitles (archive reader), PostHistoricalGameTitlesHandler (archive writer via webhook).

Each function operates within the same overall context – they use OSClient to talk to OpenSearch and share environment config – but implement a specific piece of functionality.

## Development Workflow (Building, Testing, Deploying)

**Setting up**: A new developer should install the prerequisites: Node.js 20 (with Yarn), AWS CLI, SAM CLI, and Docker. The AWS CLI should be configured (the README provides steps to set up AWS SSO credentials for the “Lobby Playground” account)[GitHub](https://gitlab.ballys.tech/excite/native/applications/personalised-lobby-ts-lambda-v3/blob/75c6ff00142d6935e18342f64345d97b3229adb6/README.md#L14-L23). Docker is used for local invocation (SAM uses Docker to emulate Lambda runtime) and for building images if needed.

**Local Builds**: The Nx monorepo means you can build all or individual projects easily:

- To build *all* functions and libraries: `yarn build` (which runs `nx run-many --target=build --all` behind the scenes)[GitHub](https://gitlab.ballys.tech/excite/native/applications/personalised-lobby-ts-lambda-v3/blob/75c6ff00142d6935e18342f64345d97b3229adb6/package.json#L14-L21). This compiles TypeScript for each project into the `dist/` directory.
- To build a specific function: `yarn nx build <functionName>` (for example, `yarn nx build GetGamesFunction`). This will produce a `dist/functions/GetGamesFunction` folder with the compiled `app.cjs` (CommonJS bundle) and any needed files.
- Nx’s build is also integrated with SAM. In the SAM template, each function has `BuildMethod: makefile` and the repository includes a `Makefile` in the OSClient library that calls a custom build script for SAM[GitHub](https://gitlab.ballys.tech/excite/native/applications/personalised-lobby-ts-lambda-v3/blob/75c6ff00142d6935e18342f64345d97b3229adb6/libs/OSClient/Makefile#L3-L5). Practically, this means running `sam build` at the project root will trigger Nx to build the functions and layer. Indeed, you do not need to pre-build manually – running `sam build` will compile everything as needed (leveraging the Nx/esbuild configuration)[GitHub](https://gitlab.ballys.tech/excite/native/applications/personalised-lobby-ts-lambda-v3/blob/75c6ff00142d6935e18342f64345d97b3229adb6/functions/GetNavigationFunction/README.md#L31-L40).

**Local Invocation**: After building, you can test Lambdas locally using SAM CLI:

- **Unit Tests**: Running `yarn test` will execute all Jest test suites for the functions and library. This is a quick way to verify logic without deploying. The tests often mock OpenSearch responses using `nock` and check that the lambdas return expected outputs for given inputs.
- **SAM Local**: For a more realistic test, use `sam local invoke`. For example:
    
    ```bash
    sam local invoke "GetNavigationFunction" -e functions/GetNavigationFunction/events/event.json --env-vars env.json
    
    ```
    
    This command (as documented in the READMEs) will start a Docker container that mimics the Lambda, pass it the event JSON (which includes a sample API Gateway event with path parameters etc.), and load environment variables from `env.json`[GitHub](https://gitlab.ballys.tech/excite/native/applications/personalised-lobby-ts-lambda-v3/blob/75c6ff00142d6935e18342f64345d97b3229adb6/functions/GetNavigationFunction/README.md#L31-L40). The function will run and you’ll see its output or error in the console. You can do this for any function by specifying its logical name (as in the template). Be sure to run `sam build` prior if code changed.
    
    There are also convenience scripts: `yarn nx run <functionName>:run` might be set up to do something similar (the Nx target `run` runs a script `scripts/run-lambda.sh` which likely calls `sam local invoke` with proper parameters)[GitHub](https://gitlab.ballys.tech/excite/native/applications/personalised-lobby-ts-lambda-v3/blob/75c6ff00142d6935e18342f64345d97b3229adb6/nx.json#L166-L174). Additionally, Nx defines targets like `sam-invoke-eu` and `sam-invoke-na` to test specific region event files and even validate outputs against expected results[GitHub](https://gitlab.ballys.tech/excite/native/applications/personalised-lobby-ts-lambda-v3/blob/75c6ff00142d6935e18342f64345d97b3229adb6/nx.json#L178-L186)[GitHub](https://gitlab.ballys.tech/excite/native/applications/personalised-lobby-ts-lambda-v3/blob/75c6ff00142d6935e18342f64345d97b3229adb6/nx.json#L184-L192).
    
- **SAM Local API**: You can also simulate the entire API locally with `sam local start-api`[GitHub](https://gitlab.ballys.tech/excite/native/applications/personalised-lobby-ts-lambda-v3/blob/75c6ff00142d6935e18342f64345d97b3229adb6/README.md#L261-L269). This spins up a local HTTP server on port 3000 that routes to your Lambda functions according to the template’s API configuration. For instance, after running `sam local start-api`, you could `curl http://localhost:3000/sites/testsite/platform/desktop/navigation` and it would execute the GetNavigationFunction. This is great for end-to-end testing of multiple endpoints or using a browser/Postman to hit the API. Ensure your `env.json` is loaded (the CLI should pick it up if named `env.json` by default).
- **Debugging**: Logging is your friend – the code uses `console.error` and a custom `logError` (which wraps console or X-Ray logging) to output errors. When running locally, these will print to console. If something isn’t working, sprinkle `console.log` or use a debugger. SAM local can be run with `-debug-port` to attach a debugger if needed.

**Deployment**: Deployment is managed via AWS SAM and GitLab CI:

- The typical deploy process (manual) would be:
    1. Run `sam build` (to compile everything and generate a packaged template).
    2. Run `sam deploy --guided` (first time) to configure deployment parameters such as stack name, AWS region, etc. For subsequent deploys, `sam deploy` (which uses `samconfig.toml` from the first time) is enough[GitHub](https://gitlab.ballys.tech/excite/native/applications/personalised-lobby-ts-lambda-v3/blob/75c6ff00142d6935e18342f64345d97b3229adb6/README.md#L175-L184)[GitHub](https://gitlab.ballys.tech/excite/native/applications/personalised-lobby-ts-lambda-v3/blob/75c6ff00142d6935e18342f64345d97b3229adb6/README.md#L182-L190). The SAM template includes all functions and will deploy/update them in AWS. The output will include the API Gateway URL (`LobbyApiUrl`) to use.
- However, in this project, deployments are likely done through **CI/CD pipelines**. The repository being linked to GitLab suggests there is a GitLab CI pipeline configured (the README mentions going to “Pipelines → Run Pipeline” in the GitLab UI to trigger a deploy)[GitHub](https://gitlab.ballys.tech/excite/native/applications/personalised-lobby-ts-lambda-v3/blob/75c6ff00142d6935e18342f64345d97b3229adb6/README.md#L299-L308). They have environment variables `CHANGES` and `ENVS` to control the pipeline. The workflow might be:
    - Developer merges code to `main`. The CI pipeline runs the semantic-release step, bumping versions and generating changelogs.
    - Images are built and pushed to Artifactory (if configured to do so on each release).
    - Deployment isn’t automatic on each commit; instead, they trigger it manually, specifying which functions to deploy and to which environment. For example, `CHANGES="lambdas/GetGamesFunction lambdas/GetNavigationFunction" ENVS="stg_eu00 prod_eu00"` might deploy only those changed lambdas to the staging and production in EU region[GitHub](https://gitlab.ballys.tech/excite/native/applications/personalised-lobby-ts-lambda-v3/blob/75c6ff00142d6935e18342f64345d97b3229adb6/README.md#L304-L312). Under the hood, the pipeline likely runs `sam deploy` with parameters that limit deployment to certain resources or uses artifact promotion.
    - The use of **nested stacks or per-function deployments** is hinted (they reference nested stack documentation[GitHub](https://gitlab.ballys.tech/excite/native/applications/personalised-lobby-ts-lambda-v3/blob/75c6ff00142d6935e18342f64345d97b3229adb6/README.md#L328-L332)). Possibly each Lambda is a nested CloudFormation stack, enabling independent deployment. If so, `CHANGES` might map to which nested stacks to update.
    - Regardless, for a newcomer, the key is: deployments are done via CloudFormation; you should follow the team’s CI process. Typically, you won’t manually run `sam deploy` to shared environments – instead you push to a branch and let CI handle it.

**Monitoring and Logging**: Once deployed, Lambdas log to CloudWatch Logs. They also might be monitored by AWS Application Insights (the template creates an ApplicationInsights monitoring resource[GitHub](https://gitlab.ballys.tech/excite/native/applications/personalised-lobby-ts-lambda-v3/blob/75c6ff00142d6935e18342f64345d97b3229adb6/template.yaml#L431-L438)). X-Ray traces can be viewed if enabled. For debugging in AWS, one can use `sam logs -n FunctionName --stack-name StackName --tail` to tail logs from a function[GitHub](https://gitlab.ballys.tech/excite/native/applications/personalised-lobby-ts-lambda-v3/blob/75c6ff00142d6935e18342f64345d97b3229adb6/README.md#L287-L295), or go to CloudWatch Logs console.

**Cleaning up**: For local stacks, `sam delete` can delete the stack if needed[GitHub](https://gitlab.ballys.tech/excite/native/applications/personalised-lobby-ts-lambda-v3/blob/75c6ff00142d6935e18342f64345d97b3229adb6/README.md#L243-L251). The README provides those commands to tear down the stack from AWS when no longer needed[GitHub](https://gitlab.ballys.tech/excite/native/applications/personalised-lobby-ts-lambda-v3/blob/75c6ff00142d6935e18342f64345d97b3229adb6/README.md#L252-L260).

## Conclusion

The *Personalised Lobby TS Lambda v3* project is a comprehensive backend solution to serve dynamic, personalized content. It leverages a combination of **headless CMS** (Contentful for authoring content), **search technology** (OpenSearch for fast retrieval and complex querying), and **serverless computing** (AWS Lambda + API Gateway for scalable request handling). The architecture ensures that non-technical users can manage the lobby content (through CMS) and that the system can tailor the experience for each player (through data and algorithms, surfaced via the personalization endpoints).

From a technical standpoint, the project showcases a well-structured monorepo using Nx, promoting reusability (with the OSClient library layer) and consistency across multiple microservices (the Lambdas). It integrates modern best practices: Infrastructure as Code (SAM/CloudFormation template), continuous integration with automated versioning, and containerization for development parity. New developers onboarding to this project should now have a clear understanding of *what* each piece does and *how* the system works as a whole – from the flow of data to the details of the build and deployment process. Both developers and non-technical stakeholders can appreciate that this system is built to be content-driven, scalable, and easily extensible: adding a new Lambda for a new endpoint is straightforward (the README even mentions a template for new lambdas), and content changes can go live without code changes, simply by updating the CMS.

By following this guide, a new contributor should be able to navigate the codebase, run the project locally, and eventually contribute to it – whether it’s adjusting an OpenSearch query for a section, or adding a new personalized endpoint – while understanding the impact on the overall personalized lobby experience.
